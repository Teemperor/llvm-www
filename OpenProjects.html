<!--#include virtual="header.incl" -->

<div class="www_sectiontitle">Open LLVM Projects</div>

<ul>
  <li><a href="#gsoc20">Google Summer of Code 2020</a>
    <ul>
    <li>
      <b>LLVM Core</b>
      <ul>
        <li><a href="#debuginfo_codegen_mismatch">Debug Info should have no
            effect on codegen</a></li>
        <li><a href="#llvm_function_attributes">Improve (function) attribute
            inference</a></li>
        <li><a href="#improve_binary_utilities">Improve LLVM binary utilities
            </a></li>
      </ul>
    </li>
    <li><a href="http://clang.llvm.org/"><b>Clang</b></a>
    <ul>
      <li><a href="#clang-template-instantiation-sugar">Extend clang AST to
          provide information for the type as written in template
          instantiations</a>
      </li>
      <li><a href="#clang-astimporter-fuzzer">Implement an ASTImporter
          fuzzer</a>
      </li>
      <li><a href="#improve-autocompletion">Improve shell autocompletion
          for Clang</a>
      </li>
      <li><a href="#analyze-llvm">Apply the Clang Static Analyzer to LLVM-based
          Projects</a>
      </li>
      <li><a href="#header-generation">Generate annotated sources based on
          LLVM-IR analyses</a>
      </li>
      <li><a href="#header-clang-diagnostic">Improve Clang diagnostics</a>
      </li>
    </ul>
    </li>
   </ul>
  </li>
  <li><a href="#what">What is this?</a></li>
  <li><a href="#subprojects">LLVM Subprojects: Clang and more</a></li>
  <li><a href="#improving">Improving the current system</a>
  <ol>
    <li><a href="#target-desc">Factor out target descriptions</a></li>
    <li><a href="#code-cleanups">Implementing Code Cleanup bugs</a></li>
    <li><a href="#programs">Compile programs with the LLVM Compiler</a></li>
    <li><a href="#llvmtest">Add programs to the llvm-test suite</a></li>
    <li><a href="#benchmark">Benchmark the LLVM compiler</a></li>
    <li><a href="#statistics">Benchmark Statistics and Warning System</a></li>
    <li><a href="#coverage">Improving Coverage Reports</a></li>
    <li><a href="#misc_imp">Miscellaneous Improvements</a></li>
  </ol></li>

  <li><a href="#new">Adding new capabilities to LLVM</a>
  <ol>
    <li><a href="#llvm_ir">Extend the LLVM intermediate representation</a></li>
    <li><a href="#pointeranalysis">Pointer and Alias Analysis</a></li>
    <li><a href="#profileguided">Profile-Guided Optimization</a></li>
    <li><a href="#compaction">Code Compaction</a></li>
    <li><a href="#xforms">New Transformations and Analyses</a></li>
    <li><a href="#codegen">Code Generator Improvements</a></li>
    <li><a href="#misc_new">Miscellaneous Additions</a></li>
  </ol></li>

  <li><a href="#using">Project using LLVM</a>
  <ol>
    <li><a href="#machinemodulepass">Add a MachineModulePass</a></li>
    <li><a href="#encodeanalysis">Encode Analysis Results in MachineInstr IR</a></li>
    <li><a href="#codelayoutjit">Code Layout in the LLVM JIT</a></li>
    <li><a href="#fieldlayout">Improved Structure Splitting and Field Reordering</a></li>
    <li><a href="#slimmer">Finish the Slimmer Project</a></li>
  </ol></li>
</ul>

<div class="doc_author">
  <p>Written by the <a href="/">LLVM Team</a></p>
</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="gsoc20">Google Summer of Code 2020</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p>
  Welcome prospective Google Summer of Code 2020 Students! This document is your
  starting point to finding interesting and important projects for LLVM, Clang,
  and other related sub-projects. This list of projects is not only developed for
  Google Summer of Code, but open projects that really need developers to work on
  and are very beneficial for the LLVM community. </p>

  <p>We encourage you to look through this list and see which projects excite you
  and match well with your skill set. We also invite proposals not on this
  list. You must propose your idea to the LLVM community through our
  developers' mailing list (llvm-dev@lists.llvm.org or specific subproject mailing
  list). Feedback from the community is a requirement for your proposal to be
  considered and hopefully accepted.
  </p>

  <p>The LLVM project has participated in Google Summer of Code for several years
  and has had some very successful projects. We hope that this year is no
  different and look forward to hearing your proposals. For information on how to
  submit a proposal, please visit the Google Summer of Code
  main <a href="https://developers.google.com/open-source/gsoc/">website.</a></p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>LLVM</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Clang</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>LLDB</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="lldb-reimplement-lldb-cmdline">Reimplement LLDB's command-line commands
  using the public SB API.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b> Just as LLVM is a library to
    build compilers, LLDB is a library to build debuggers. LLDB vends
    a stable, public SB API. Due to historic reasons the LLDB command
    line interface is currently implemented on top of LLDB's private
    API and it duplicates a lot of functionality that is already
    implemented in the public API. Rewriting LLDB's command line
    interface on top of the public API would simplify the
    implementation, eliminate duplicate code, and most importantly
    reduce the testing surface.
  </p>
  <p>
    This work will also provide an opportunity to clean up the SB API
    of commands that have accrued too many overloads over time and
    convert them to make use of option classes to both gather up all
    the variants and also future-proof the APIs.
  </p>
  <p><b>Confirmed Mentor:</b>Adrian Prantl and Jim Ingham</p>

  <p><b>Desirable skills:</b>
    Intermediate knowledge of C++.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="lldb-data-formatters">Implement a DSL for LLDB data formatters</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b> LLDB's data formatters allow it to pretty-print objects such as std::vector (from the C++ standard library), or String (from the Swift standard library). These data formatters are implemented in C++ and reside within the debugger, but the data structures are defined in other projects. This means that when the data structures change, lldb's data formatters may not be updated in sync. This also means that it's difficult for projects to define and test custom data formatters for special kinds of objects.  </p>
  <p><b>Expected results: </b> The goal of this project would be to define a DSL which makes it possible to implement lldb data formatters for standard C++ containers. These formatters would be moved into libc++ and tested there. </p>
  <p><b>Confirmed Mentor:</b> Vedant Kumar and Davide Italiano</p>

  <p><b>Desirable skills:</b>
    Intermediate knowledge of C++.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="lldb-batch-testing">Add support for batch-testing to the LLDB
    testsuite.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>One of the tensions in the
    testsuite is that spinning up a process and getting it to some
    point is not a cheap operation, so you'd like to do a bunch of
    tests when you get there.  But the current testsuite bails at the
    first failure, so you don't want to do many tests since the
    failure of one fails all the others. On the other hand, there are
    some individual test assertions where the failure of the assertion
    <em>should</em> cause the whole test to fail.  For example, if you
    fail to stop at a breakpoint where you want to check some variable
    values, then the whole test should fail.  But if your test then
    wants to check the value of five independent locals, it should be
    able to do all five, and then report how many of the five variable
    assertions failed. We could do this by adding <em>Start</em>
    and <em>End</em> markers for a batch of tests, do all the tests in
    the batch without failing the whole test, and then report the
    error and fail the whole test if appropriate. There might also be
    a nice way to do this in Python using scoped objects for the test
    sections.
  </p>
  <p><b>Confirmed Mentor:</b> Jim Ingham</p>

  <p><b>Desirable skills:</b>
    Intermediate knowledge of Python.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="gsoc19">Google Summer of Code 2019</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p>Google Summer of Code 2019 contributed a lot to the LLVM project. Below is a
  list of some projects that were offerred during GSoC 2018. For the list of
  accepted and completed projects, please take a look into Google Summer of Code
  <a href="https://summerofcode.withgoogle.com/archive/2019/organizations/5682474363912192/">website.
  </a></p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>LLVM</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="debuginfo_codegen_mismatch">Debug Info should have no
          effect on codegen</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  Adding Debug Info (compiling with `clang -g`) shouldn't change the
	  generated code at all. Unfortunately we have bugs. These are usually not
	  too hard to fix and a good way to discover new part of the codebase!
	  We suggest building object files both ways and disassembling the
          text sections, which will give cleaner diffs than comparing .s files.
  </p>

  <p><b>Expected results:</b> Reduced test cases, bug reports with analysis
          (e.g., which pass is responsible), possibly patches.</p>

  <p><b>Confirmed Mentor:</b> Paul Robinson</p>
  <p><b>Desirable skills:</b> Intermediate knowledge of C++, some familiarity
        with x86 or ARM instruction set.</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="llvm_function_attributes">Improve (function) attribute inference</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
  LLVM functions, as well as arguments and other entities, can be tagged with
  several <a href="/docs/LangRef.html#function-attributes">attributes</a> such
  as the function only reads memory, or the function cannot throw exceptions.
  These attributes are used by many optimizations when deciding if a particular
  transformation is valid or not. Functions attributes can be either given by
  the frontend or be inferred by LLVM.
  </p>

  <p>
  The goal of this project is to improve/replace the current function
  attributes inference algorithms, and to infer attributes that are not
  inferred right now. This will be accomplished via intra- and/or
  inter-procedural analyses.
  </p>

  <p><b>Background and further reading</b>
  See <a href="http://lists.llvm.org/pipermail/llvm-dev/2018-February/121269.html">this
  email</a> for a list of opportunities for improvement, <a
  href="https://lists.llvm.org/pipermail/llvm-dev/2018-August/125537.html">this
email thread</a> for a description of the current implementation, its problems,
and a alternative approach. Finally, find a (currently still rough) prototype
of the proposed alternative, which would be the starting point for this project,
<a href="https://reviews.llvm.org/D59202">here</a>.
  </p>

  <p><b>Confirmed Mentor:</b> Johannes Doerfert, Nuno Lopes</p>
  <p><b>Desirable skills:</b> Intermediate knowledge of C++ and familiarity with static analysis/abstract interpretation.</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="improve_binary_utilities">Improve LLVM binary utilities</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b> Binary utilities (aka binutils) are a
    set of tools used to inspect and analyze generated binary files. We have
    recently developed new versions of these in the LLVM project so we can
    remove the need for their GNU equivalents. The base functionality is done,
    but there are many missing features. In this project you will be
    contributing to the LLVM binutils, adding these additional features, in
    tools such as llvm-readobj, llvm-objdump and llvm-objcopy. This will require
    you to become an expert in the specification details for various object file
    formats, such as ELF and COFF.</p>
  <p><b>Expected Results:</b> Patch contributions to the LLVM binary utilities
    to improve the quality of existing features and to add missing
    functionality.</p>
  <p><b>Confirmed Mentor:</b> James Henderson, Jordan Rupprecht</p>
  <p><b>Desirable skills:</b> Intermediate knowledge of C++.</p>
</div>


<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Clang</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-template-instantiation-sugar">Extend clang AST to provide
    information for the type as written in template instantiations.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    When instantiating a template, the template arguments are canonicalized
    before being substituted into the template pattern. Clang does not preserve
    type sugar when subsequently accessing members of the instantiation.

    <pre>
    std::vector&lt;std::string&gt; vs;
    int n = vs.front(); // bad diagnostic: [...] aka 'std::basic_string&lt;char&gt;' [...]

    template&lt;typename T&gt; struct Id { typedef T type; };
    Id&lt;size_t&gt;::type // just 'unsigned long', 'size_t' sugar has been lost
    </pre>

    Clang should "re-sugar" the type when performing member access on a class
    template specialization, based on the type sugar of the accessed
    specialization. The type of vs.front() should be std::string, not
    std::basic_string&lt;char, [...]&gt;.
    <br /> <br />
    Suggested design approach: add a new type node to represent template
    argument sugar, and implicitly create an instance of this node whenever a
    member of a class template specialization is accessed. When performing a
    single-step desugar of this node, lazily create the desugared representation
    by propagating the sugared template arguments onto inner type nodes (and in
    particular, replacing Subst*Parm nodes with the corresponding sugar). When
    printing the type for diagnostic purposes, use the annotated type sugar to
    print the type as originally written.
    <br /> <br />
    For good results, template argument deduction will also need to be able to
    deduce type sugar (and reconcile cases where the same type is deduced twice
    with different sugar).
  </p>

  <p><b>Expected results: </b>
    Diagnostics preserve type sugar even when accessing members of a template
    specialization. T&lt;unsigned long&gt; and T&lt;size_t&gt; are still the
    same type and the same template instantiation, but
    T&lt;unsigned long&gt;::type single-step desugars to 'unsigned long' and
    T&lt;size_t&gt;::type single-step desugars to 'size_t'.

  <p><b>Confirmed Mentor:</b> Vassil Vassilev, Richard Smith</p>

  <p><b>Desirable skills:</b>
    Good knowledge of clang API, clang's AST, intermediate knowledge of C++.
  </p>
</div>


<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-astimporter-fuzzer">Implement an ASTImporter fuzzer</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    Clang contains an ASTImporter which allows moving declarations and
    statements from one Clang AST to another. This is for example used for
    static analysis across translation units and in LLDB's expression
    evaluator.
  </p>
  <p>
    The current ASTImporter works as intended when moving simple C code from
    one AST to another. However, more complicated declarations such as C++'s
    OOP features and templates are not fully implemented and can cause crashes
    or invalid AST nodes. The bug reports related to these crashes are often
    filed against LLDB's expression evaluator and are rarely submited with a
    minimal reproducer. This makes improving ASTImporter a time-consuming and
    tedious task.
  </p>
  <p>
    This project is about writing a fuzzer to proactively discover these
    ASTImporter bugs and provide minimal reproducers which make understanding
    and fixing the underlying bug easier.
  </p>
  <p>
    A possible implementation of such a fuzzer and driver could look like this:

  <ul>
    <li>Generate some source code that can be imported (either fully randomly
        or based on existing source code from a user-given code corpus).</li>
    <li>Import randomly a few declarations from this AST. The AST in which
        they are imported to can already be populated with declarations.</li>
    <li>Run Clang's code generator over our imported AST.</li>
    <li>If we hit an assert during the import or CodeGen steps we probably
        found an ASTImporter bug.</li>
    <li>The fuzzer driver should now reduce the size of the source code
        until it is as small as possible and still reproduces the crash (e.g.
        by running Creduce with an automatically generated test script).</li>
    <li>The reproducer should now be stored in a format so that it can just be
        copied into Clang's regression test suite for the ASTImporter (see
        the <a href="https://github.com/llvm/llvm-project/tree/master/clang/test/Import">clang/test/Import/</a> directory).
        The reproducer must still reproduce the found bug when run as part
        of the test suite.
        </li>
  </ul>
  This is just one possible approach and students are welcome to submit their
  own ideas on how the fuzzer should operate. Approaches that allow to
  automatically verify more aspects of the imported AST (e.g. the source
  locations of AST nodes, size of RecordDecls) are encouraged. The fuzzer and
  driver should be implemented in C++ and/or Python.
  </p>
  <p><b>Confirmed Mentor:</b> Raphael Isemann, Shafik Yaghmour</p>
  <p><b>Desirable skills:</b> Intermediate knowledge of C++.</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="improve-autocompletion">Improve shell autocompletion for Clang</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b> Clang has a newly implemented autocompletion feature which details can be found at <a href="http://blog.llvm.org/2017/09/clang-bash-better-auto-completion-is.html">LLVM blog</a>. We would like to improve this by adding more flags to autocompletion, supporting more shells (currently it supports only bash) and exporting this feature to other projects such as llvm-opt. Accepted student will be working on Clang Driver, LLVM Options and shell scripts.
  </p>

  <p><b>Expected Results:</b> Autocompletion working on bash and zsh, support llvm-opt options.</p>

  <p><b>Confirmed Mentor:</b> Yuka Takahashi and Vassil Vassilev</p>

  <p><b>Desirable skills:</b>
  Intermediate knowledge of C++ and shell scripting
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="analyze-llvm">Apply the Clang Static Analyzer to LLVM-based
  Projects</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	The idea is to improve the Clang Static Analyzer so that it is useful
	for developers who work on Clang and LLVM themselves, as well as on other
  LLVM-based projects, like Swift. LLVM makes use of C++ language features that
  the Static Analyzer has not yet been taught to understand. The analyzer also
  has false positives on some C++ idioms commonly used in the LLVM codebase.
  </p>
  <p>
	The Static Analyzer is already useful for a variety of projects, but in order
  to reach the "use your own tools" checkpoint, we'll have to classify, debug,
  and, ideally, eliminate the most common sources of false positives
  on our code. It would be the best to fix false positives by improving
  the Static Analyzer itself, but it may also sometimes be feasible to add
  a few suppressions (such as assertions) within the LLVM source code so that
  it is easier for both humans and the Analyzer to understand what's going on.
  And, of course, it would be great to report and maybe even fix the true
  positives that we manage to find!
  </p>

  <p><b>Expected results:</b>
  Results produced by the Analyzer on LLVM itself should become more or
  less correct: warnings are useful, false alarms are gone. This lets
  more and more LLVM developers adopt the Static Analyzer in their daily lives
  or CI workflows.
  </p>

  <p><b>Confirmed Mentor:</b> Artem Dergachev, Ravi Kandhadai Madhavan</p>
  <p><b>Desirable skills:</b> Intermediate knowledge of C++.</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="header-generation">Generate annotated sources based on
          LLVM-IR analyses</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Background and motivation:</b>
  During the compilation of a piece of code, LLVM derives various facts that are
  only used while the respective translation unit (TU), or LLVM module, is
  processed. This holds for standard compilation but also
  link-time-optimization (LTO) in which the module is (partially) merged with
  others, that are part of the same project, at link time. In either scenario
  there are drawbacks: In single TU compilation, the derived information is not
  accessible to other TUs, which generally leads to performance loss in the
  presence of cross TU accesses or calls. In LTO-mode, only the parts build
  together in LTO-mode, or distributed in LTO-mode, will benefit from cross TU
  optimizations. This means for example that pre-build (proprietary)
  third-party libraries are precluded. Any LTO approach, including thin-LTO,
  will additionally come with a non-trivial compile time investment.</p>

  <p><b>Description of the project:</b>
  In this project we propose to expose the LLVM derived facts to the outside
  world by annotating the respective declarations in the source, mostly header,
  files. These annotations can vary in their expressiveness and compatibility
  with the existing base language annotations but they should always allow
  subsequent compilations, which include the annotated source files, to produce
  better code in the presence of cross TU accesses and calls.</p>

  <p><b>Expected results:</b>
  A prototype implementation that can generate annotated source code based on
  LLVM-IR attributes. Additionally, a comparison of this optimization approach
  to single TU, thin-LTO, and LTO compilation, with regards to compile time,
  memory consumption, and execution time.
  </p>

  <p><b>Confirmed Mentor:</b> Johannes Doerfert, Brian Homerding</p>
  <p><b>Desirable skills:</b> Good knowledge of C and C++ semantics,
                              C++ coding experience</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="header-clang-diagnostic">Improve Clang Diagnostics</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Decription:</b>
  Clang diagnostics (warnings and errors) issues to the programmer are a critical
  feature of the compiler. Great diagnostics can have a signifiant impact on the
  user experience of the compiler and increase their productivity.
  </p>

  <p><a href="https://developers.redhat.com/blog/2019/03/08/usability-improvements-in-gcc-9/">
  Recent improvements in GCC 9.0</a> show that there is significant headroom to
  improve diagnostics (and user interactions in general). It would be a very
  impactful project to survey and identify all the possible improvements to clang
  on this topic, and start resigning the next generation of our diagnostics.
  </p>

  <p><b>Desirable skills:</b> C++ coding experience</p>
</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="gsoc18">Google Summer of Code 2018</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p>Google Summer of Code 2018 contributed a lot to the LLVM project. Below is a
  list of some projects that were offerred during GSoC 2018. For the list of
  accepted and completed projects, please take a look into Google Summer of Code
  <a href="https://summerofcode.withgoogle.com/archive/2018/organizations/5263452624912384/">website.
  </a></p>
</div>


<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>LLVM</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="codegen_testing2018">Improve code generation testing</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p>
    <b>Description of the project:</b>
    After instruction selection LLVM uses the MI (Machine Instruction)
    representation for programs. We recently added support for reading and
    writing this representation to disk
    (<a href="/docs/MIRLangRef.html">http://llvm.org/docs/MIRLangRef.html</a>). Usage of this format for writing
    tests is growing and so is the desire to improve the format, tools and
    workflow. Possible projects:
  </p>

  <ul>
    <li>Create a single consistent format instead of the current mix of YAML + IR + MIR</li>
    <li>Helper passes: Strip IR information, rename blocks and values, debug information, extract functions or blocks...</li>
    <li>Create a bugpoint mode (or a new tool) to reduce .mir test cases</li>
    <li>Create tool to remove unnecessary information from existing tests</li>
  </ul>

  <p><b>Confirmed Mentor:</b> Matthias Braun</p>
  <p><b>Desirable skills:</b> Intermediate knowledge of C++.</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="llvm_optimized_debugging">Improve debugging of optimized code</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p>
  <b>Description of the project:</b> Debugging optimized code can be frustrating. Variables may appear as "&lt;value optimized out&gt;" in the debugger, or may not appear at all. Line numbers in stack traces may disappear, or worse, become inaccurate. To improve the situation, we have to teach more LLVM optimization passes how to preserve debug info. The primary focus will be on mid-level IR passes which fail to pass verification by the <a href="https://reviews.llvm.org/D40512">Debugify utility</a>. This utility can identify passes which drop debug info in a targeted way and can simplify test case generation.
  </p>
  <p><b>Expected Results:</b>This project has two goals. Initially, the student will gather metrics on debug info loss for individual llvm passes. This will let us measure subsequent improvements. The second goal is to incrementally fix as many debug info loss bugs as possible, with a focus on areas of the compiler which are the hottest.</p>

  <p><b>Confirmed Mentor:</b> Vedant Kumar and Davide Italiano</p>
  <p><b>Desirable skills:</b> Intermediate knowledge of C++.</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="replace_binary_utilities">Command line replacements for GNU Binutils</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b> The llvm project has a lot of tools that can be used to inspect binaries, as any other toolchain project does. Many people are accustomed to existing tools and so having a command line compatible shell and we'd like to make that easy for them. Bonus points for producing similar output so that automated tools can continue to work reliably.
  <p><b>Expected Results:</b>This project has one goal - produce binary tools that are drop in compatible with GNU binutils. The student will be expected to focus on a single tool at a time so that we can count each one as "done" as much as possible.

  <p><b>Confirmed Mentor:</b> Eric Christopher and Sterling Augustine</p>
  <p><b>Desirable skills:</b> Intermediate knowledge of C++.</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="llvm_domtree_updater">Implement a single updater class for Dominators</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b> Dominance relation is used widely in many compiler analyses and optimizations. LLVM provides an implementation of the (Semi-NCA) Depth Based Search algorithm to incrementally update Dominator and PostDominator Trees. It it possible to use it directly or through a lazy updater object -- DeferredDominance. The current API is fragmented and different analyzes, transforms, and utilities (e.g. Local.cpp, LoopUnroll.cpp) have to decide how to perform incremental updates.
  </p>
  <p>The fix would be to design and implement a new class for abstracting away how tree updates are performed (eagerly or lazily) and which trees are actually being updated (none, only DomTree, only PostDomTree, both). With this, performing faster incremental updates will become possible by first updating DomTree, and then using the result to prune unnecessary updates to PostDomTree.</p>

  <p>Expected Results:
    <ul><li>Create a new class that will store Dominator Trees to update and allow to specify update policy.</li></ul>
    <ul><li>Convert existing API to use the new updater object instead of working directly with DomTree/DeferredDominance.</li></ul>
    <ul><li>Design and implement a new algorithm to prune unnecessary PostDomTree updates based on updated DomTree.</li></ul>
    <ul><li>(Optional) Explore more strategies for performing lazy updates (e.g. by exposing .dominates() and performing updates when called).</li></ul>
  </p>
  <p><b>Confirmed Mentor:</b> Jakub Kuderski, Tobias Grosser (?)</p>
  <p><b>Desirable skills:</b> Intermediate knowledge of C++. Familiarity with basic tree/graph algorithms and data structures.</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Clang</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Clang Tools Extra</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="doc-html-generator">Implement an HTML generator for clang-doc.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
   Clang-doc is a new tool for generating documentation for C/C++ code with a modular and extensible approach. It aims to simplify the overhead of generating documentation, leveraging the clang AST to produce results from existing comments and code. The main part of the tool produces an intermediate representation of the docs, which is consumed by a generator targeting a specific output format. Current and in-progress generators emit documentation in YAML and Markdown formats, but we’d like to have another one for HTML format.
  </p>
  <p><b>Confirmed Mentor:</b> Julie Hockett</p>
  <p><b>Desirable skills:</b> Intermediate knowledge of C++.</p>
</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="gsoc17">Google Summer of Code 2017</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p>Google Summer of Code 2017 contributed a lot to the LLVM project. Below is a
  list of some projects that were offerred during GSoC 2017. For the list of
  accepted and completed projects, please take a look into Google Summer of Code
  <a href="https://summerofcode.withgoogle.com/archive/2017/organizations/6215410651234304/">website.
  </a></p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>LLVM</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="bitcode_fuzzing">Fuzzing the Bitcode reader</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="debuginfo_overhead">Improve optimizer overhead with debug info</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  The optimizer is 25-30% slower when debug info are enabled, it'd be nice
	  to track all the places where we don't do a good job about ignoring them!
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="thinlto_global">ThinLTO: propagating more global informations across
	  the program for more powerful optimizations!</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  ThinLTO is a cool new technology to perform Link-Time Optimization (see
	  <a href="/devmtg/2016-11/#talk12">this talk</a> for more info). It is fairly new
	  and there are multiple improvements about cross-module optimizations that
	  can be made there.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="debuginfo_codegen_mismatch"></a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  Adding Debug Info (compiling with `clang -g`) shouldn't change the
	  generated code at all. Unfortunately we have bugs… These are usually not
	  too hard to fix and a good way to discover new part of the codebase! A
	  starting point could be the test-suite. We suggest building object files
	  both ways and disassembling the text sections, which will give cleaner
	  diffs than comparing .s files.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="hashmap_codegen_mismatch">Changing the iteration order of unordered
	  datastructures should not change the generated code.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="opt_remarks">We need better optimization remarks!</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  See <a href="/devmtg/2016-11/#talk15">this talk</a>
	  for a starting point.  Please take a look at the list of
	  enhancements and bugs in <a href=
	  "https://bugs.llvm.org/buglist.cgi?component=opt-viewer&list_id=125824&product=tools&query_format=advanced&resolution=---">
	  bugzilla</a>.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="llvmir_dump">Smarter way of dumping LLVM IR with -emit-after-all</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  Smarter way of dumping LLVM ir with -emit-after-all - dump only if it
	  differs from last pass. Maybe small color the IR?
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="codegen_testing">Improve code generation testing</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  After instruction selection LLVM uses the MI (Machine Instruction)
	  representation for programs. We recently added support for reading and
	  writing this representation to disk
	  (<a href="/docs/MIRLangRef.html">http://llvm.org/docs/MIRLangRef.html</a>). Usage of this format for writing
	  tests is growing and so is the desire to improve the format, tools and
	  workflow. Improvements would be welcome:

	  <ul><li>Create a single consistent format instead of the current mix of
		  YAML + IR + MIR</li></ul>
	  <ul><li>Do not print unnecessary information (we often print default
		  values where the reader could deduce them)</li></ul>
	  <ul><li>The format of things like MachineInstr/MachineBasicBlock::dump()
		  should be the same or very close to the .mir format => change the dump
		  functions.</li></ul>
	  <ul><li>Allow the representation to deduce successors of a basic block in
		  common cases</li></ul>
	  <ul><li>Allow symbolic names instead of only numbers for virtual
		  registers</li></ul>
	  <ul><li>Helper passes: Strip IR information, rename blocks and values,
		  debug information, ...</li></ul>
	  <ul><li>Create a bugpoint mode (or a new tool) to reduce .mir test cases</li></ul>
	  <ul><li>Write recommendations and guides for .mir based tests</li></ul>
  </p>

   <p><b>Confirmed Mentor:</b> Matthias Braun</p>
</div>


<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Clang</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-template-instantiation-sugar">Extend clang AST to provide
    information for the type as written in template instantiations.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    When instantiating a template, the template arguments are canonicalized
    before being substituted into the template pattern. Clang does not preserve
    type sugar when subsequently accessing members of the instantiation.

    <pre>
    std::vector&lt;std::string&gt; vs;
    int n = vs.front(); // bad diagnostic: [...] aka 'std::basic_string&lt;char&gt;' [...]

    template&lt;typename T&gt; struct Id { typedef T type; };
    Id&lt;size_t&gt;::type // just 'unsigned long', 'size_t' sugar has been lost
    </pre>

    Clang should "re-sugar" the type when performing member access on a class
    template specialization, based on the type sugar of the accessed
    specialization. The type of vs.front() should be std::string, not
    std::basic_string&lt;char, [...]&gt;.
    <br /> <br />
    Suggested design approach: add a new type node to represent template
    argument sugar, and implicitly create an instance of this node whenever a
    member of a class template specialization is accessed. When performing a
    single-step desugar of this node, lazily create the desugared representation
    by propagating the sugared template arguments onto inner type nodes (and in
    particular, replacing Subst*Parm nodes with the corresponding sugar). When
    printing the type for diagnostic purposes, use the annotated type sugar to
    print the type as originally written.
    <br /> <br />
    For good results, template argument deduction will also need to be able to
    deduce type sugar (and reconcile cases where the same type is deduced twice
    with different sugar).
  </p>

  <p><b>Expected results: </b>
    Diagnostics preserve type sugar even when accessing members of a template
    specialization. T&lt;unsigned long&gt; and T&lt;size_t&gt; are still the
    same type and the same template instantiation, but
    T&lt;unsigned long&gt;::type single-step desugars to 'unsigned long' and
    T&lt;size_t&gt;::type single-step desugars to 'size_t'.

  <p><b>Confirmed Mentor:</b> Vassil Vassilev, Richard Smith</p>

  <p><b>Desirable skills:</b>
    Good knowledge of clang API, clang's AST, intermediate knowledge of C++.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-diff-tool">Clang-based C/C++ diff tool.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    Every developer has to interact with diff tools daily. The algorithms are
    usually based on detecting "longest common subsequences", which is agnostic
    to the file type content. A tool that would understand the structure of the
    code may provide a better diff experience by being robust against, for
    example, clang-format changes.
  </p>
  <p><b>Confirmed Mentor:</b> Mehdi Amini</p>
</div>


<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Clang-tidy</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-tidy-pointer-deref">Find dereference of pointers.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    Find dereference of pointer before checking for nullptr, like:
    <pre>
      Int * p = foo();
      *p = 42;
      If (p != nullptr) { // p != nullptr is considered as always true
      }
      If (!p) { // !p is considered as always false
      }
    </pre>

    <br /><br />
    This check should be easier to write in clang-tidy than in Clang Static
    Analyzer, specially because that we don't care about inlining (as long as it
    doesn't modify pointer). More details in the
    <a href="/bugs/show_bug.cgi?id=30232">Bugzilla feature
      request</a>
  </p>
  <p><b>Confirmed Mentor:</b> Alexander Kornienko, Piotr Padlewski</p>
</div>


<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Clang Static Analyzer</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-sa-virt-calls">Warn if virtual calls are made from constructors
    or destructors.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    Implement a path-sensitive checker that warns if virtual calls are made from
    constructors and destructors, which is not valid in case of pure virtual
    calls and could be a sign of user error in <a href="https://isocpp.org/wiki/faq/strange-inheritance#calling-virtuals-from-ctors">non-pure calls</a>.
    <br />
    The current virtual calls checker, implemented in VirtualCallChecker.cpp,
    needs to be re-implemented in a path-sensitive way.  The lack of
    path-sensitive reasoning may result in false positives in the
    inter-procedural mode, which is disabled now for that reason.
    The false positives could happen when a called function uses a member
    variable flag to track whether initialization is complete and relies on the
    flag to ensure that the virtual member function is not called during
    initialization. Further, the path diagnostic should be used to highlight
    both the virtual call and the path from the constructor. Last, we will need
    to evaluate if the warning should be issued for both calls to pure virtual
    functions (which is always an error) and non-pure virtual functions (which
    is more of a code smell and may be a false positive).
  </p>
  <p><b>Confirmed Mentor:</b> Anna Zaks</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-sa-atomics">Model C++11 and C11 atomics in the analyzer.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    Enhance the clang static analyzer by adding models of C++11 and C11 atomic
    operations, such as std::atomic_compare_exchange_*. Currently, these
    operations are being treated opaquely, which results in loss of precision
    when analyzing the code that uses these instructions. To address the
    problem, one would need to programmatically construct AST that simulates
    these APIs to the BodyFarm of the analyzer. BodyFarm is the API used for
    modeling system APIs. Finally, the work would also include writing tests
    for the various APIs and checking that the analyzer correctly models
    atomics.
  </p>
  <p><b>Confirmed Mentor:</b> Anna Zaks</p>
</div>



<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Compiler-rt</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="compiler-rt-port-to-other-platforms">Port compiler-rt components to
    other platforms.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    Many of the projects in compiler-rt are only supported on Linux.
    <br />
    Here are some examples: CFI, DFSan, XSan, LSan, XRay. Porting any of them
    to other platforms, for example, Mac OS, would be great!
  </p>
  <p><b>Confirmed Mentor:</b> Kuba Mracek, Anna Zaks</p>
</div>


<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>LLD</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="lld_layout">Improve Code Layout</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
	The goal for the project is trying to improve the layout/performances of the
	generated executable. The primary object format considered for the project
	is ELF but this can be extended to other object formats. The project will
	touch both LLVM and lld.
	<ul>
		<li>Warm-up: lld already provides an option to (--symbol-ordering file)
			which takes a symbol ordering file (presumably collected from a
			profiler) and builds a layout. This aims to reduce startup times. It
			would be nice to provide scripts to profile the applications/process
			various profilers output to produce an order file/evaluate the
			impact of the feature (as it has been tested only on a small class
			of applications). There's already some work in the area but nothing
			has been integrated in the LLVM build system for ELF. Ideally a
			motivated student would do the benchmarking/analysis before the GSoC
			starts to familiarize with the problem.</li>
		<li>The meat: Use/extend profile information generated by LLVM to help
			the linker lay out functions. An example way (what gcc uses, [1])
			is to pass values to the linker using special `.note` sections. The
			linker then can reconstruct the call graph and apply an algorithm
			like the one described in [2] (this is a starting point, other
			alternatives can be explored).</li>
	</ul>
  </p>
  <p>
	Possible extension: Xray can be used to provide data (it's unclear whether
	this is feasible easily, see David's comment in [3]).
  </p>
  <p><b>Confirmed Mentor:</b> Davide Italiano</p>

  <ul>
    <li>[1] <a href="http://sourceware.org/ml/binutils/2011-03/msg00043.html">http://sourceware.org/ml/binutils/2011-03/msg00043.html</a></li>
    <li>[2] <a href="http://dl.acm.org/citation.cfm?id=93550">http://dl.acm.org/citation.cfm?id=93550</a></li>
    <li>[3] <a href="http://lists.llvm.org/pipermail/llvm-dev/2017-January/109114.html">http://lists.llvm.org/pipermail/llvm-dev/2017-January/109114.html</a></li>
  </ul>
</div>

<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Polly</a>
</div>
<!-- *********************************************************************** -->


<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="pollypgo">Profile Guided Optimization in Polly</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
  Even though Polly's compile time is today not a lot higher than other non-trial
  IR passes, the need to version code in many situations and the lack of static
  knowledge about loop iteration counts, hotness of functions, and parameter
  requires Polly to be significantly more conservative than it would need to
  be. The goal of this project is to connect Polly with the LLVM profiling
  infrastructure to exploit profiling information to decide: 1) when to
  run Polly, 2) how aggressive to version the code, 3) which code version
  to emit, and 4) which assumptions to take. As a result, Polly should can
  in profile guided builds become more aggressive, while still having a lower
  compile time and code size impact.
  </p>

  <p><b>Confirmed Mentor:</b> <a href="mailto:tobias@grosser.es">Tobias Grosser</a></p>

  <ul>
    <li>PGO in LLVM: <a href="/devmtg/2013-11/">2013 developer's meeting presentation</a>
  </ul>
</div>


<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="what">What is this?</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">

<p>This document is meant to be a sort of "big TODO list" for LLVM.  Each
project in this document is something that would be useful for LLVM to have, and
would also be a great way to get familiar with the system.  Some of these
projects are small and self-contained, which may be implemented in a couple of
days, others are larger.  Several of these projects may lead to interesting
research projects in their own right.  In any case, we welcome all
contributions.</p>

<p>If you are thinking about tackling one of these projects, please send a mail
to the <a href="http://lists.llvm.org/mailman/listinfo/llvm-dev">LLVM
Developer's</a> mailing list, so that we know the project is being worked on.
Additionally this is a good way to get more information about a specific project
or to suggest other projects to add to this page.
</p>

<p>The projects in this page are open-ended. More specific projects are
filed as unassigned enhancements in the <a href="http://bugs.llvm.org/">
LLVM bug tracker</a>. See the <a href="http://bugs.llvm.org/buglist.cgi?keywords_type=allwords&amp;keywords=&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;bug_severity=enhancement&amp;emailassigned_to1=1&amp;emailtype1=substring&amp;email1=unassigned">list of currently outstanding issues</a> if you wish to help improve LLVM.</p>

</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="subprojects">LLVM Subprojects: Clang and More</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">

<p>In addition to hacking on the main LLVM project, LLVM has several subprojects,
   including Clang and others.  If you are interested in working on these, please
   see their "Open projects" page:</p>

<ul>
<li>The <a href="http://clang.llvm.org/OpenProjects.html">Clang Open
    Projects</a> list.</li>
<li>The <a href="http://polly.llvm.org/projects.html">Polly Open
    Projects</a> list.</li>
<li>The <a href="http://sva.cs.illinois.edu/projects.html">SAFECode Open
    Projects</a> list.</li>
</ul>

</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="improving">Improving the current system</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">

<p>Improvements to the current infrastructure are always very welcome and tend
to be fairly straight-forward to implement.  Here are some of the key areas that
can use improvement...</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="target-desc">Factor out target descriptions</a>
</div>

<div class="www_text">

<p>Currently, both Clang and LLVM have a separate target description infrastructure,
with some features duplicated, others "shared" (in the sense that Clang has to create
a full LLVM target description to query specific information).</p>

<p>This separation has grown in parallel, since in the beginning they were quite
different and served disparate purposes. But as the compiler evolved, more and
more features had to be shared between the two so that the compiler would behave
properly. An example is when targets have default features on speficic configurations
that don't have flags for. If the back-end has a different "default" behaviour
than the front-end and the latter has no way of enforcing behaviour, it
won't work.</p>

<p>An alternative would be to create flags for all little quirks, but first, Clang
is not the only front-end or tool that uses LLVM's middle/back ends, and second,
that's what "default behaviour" is there for, so we'd be missing the point.</p>

<p>Several ideas have been floating around to fix the Clang driver WRT recognizing
architectures, features and so on (table-gen it, user-specific configuration files,
etc) but none of them touch the critical issue: sharing that information with the
back-end.</p>

<p>Recently, the idea to factor out the target description infrastructure from
both Clang and LLVM into its own library that both use, has been floating around.
This would make sure that all defaults, flags and behaviour are shared, but would
also reduce the complexity (and thus the cost of maintenance) a lot. That would
also allow all tools (lli, llc, lld, lldb, etc) to have the same behaviour
across the board.</p>

<p>The main challenges are:</p>

<ul>
  <li>To make sure the transition doesn't destroy the delicate balance on any
  target, as some defaults are implicit and, some times, unknown.</li>
  <li>To be able to migrate one target at a time, one tool at a time and still
  keep the old infrastructure intact.</li>
  <li>To make it easy for detecting target's features for both front-end and
  back-end features, and to merge both into a coherent set of properties.</li>
  <li>To provide a bridge to the new system for tools that haven't migrated,
  especially the off-the-tree ones, that will need some time (one release,
  at least) to migrate..</li>
</ul>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="code-cleanups">Implementing Code Cleanup bugs</a>
</div>

<div class="www_text">

<p>
The <a href="http://bugs.llvm.org/">LLVM bug tracker</a> occasionally
has <a
  href="http://bugs.llvm.org/buglist.cgi?short_desc_type=allwordssubstr&amp;short_desc=&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=code-cleanup&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;emailassigned_to1=1&amp;emailtype1=substring&amp;email1=&amp;emailassigned_to2=1&amp;emailreporter2=1&amp;emailcc2=1&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;changedin=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=Bug+Number&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">"code-cleanup" bugs</a> filed in it.
Taking one of these and fixing it is a good way to get your feet wet in the
LLVM code and discover how some of its components work.  Some of these include
some major IR redesign work, which is high-impact because it can simplify a lot
of things in the optimizer.
</p>

<p>
Some specific ones that would be great to have:

<ul>
<li><a href="/PR10367">Fix the design of GlobalAlias to not require dest type to match source type</a></li>
<li><a href="/PR10368">Redesign ConstantExpr's</a></li>
<li><a href="/PR11944">Static constructors should be purged from LLVM</a></li>
</ul>
</p>

<p>Additionally, there are performance improvements in LLVM that need to get
fixed. These are marked with the <tt>slow-compile</tt> keyword. Use
<a href="http://bugs.llvm.org/buglist.cgi?short_desc_type=allwordssubstr&amp;short_desc=&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=slow-compile&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;emailassigned_to1=1&amp;emailtype1=substring&amp;email1=&amp;emailassigned_to2=1&amp;emailreporter2=1&amp;emailcc2=1&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;changedin=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;namedcmd=Bugs+I+Fixed&amp;newqueryname=&amp;order=Reuse+same+sort+as+last+time&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">this Bugzilla query</a>
to find them.</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="llvmtest">Add programs to the llvm-test testsuite</a>
</div>

<div class="www_text">

<p>
The <a href="docs/TestingGuide.html#wholeprograms">llvm-test</a> testsuite is
a large collection of programs we use for nightly testing of generated code
performance, compile times, correctness, etc.  Having a large testsuite gives
us a lot of coverage of programs and enables us to spot and improve any
problem areas in the compiler.</p>

<p>
One extremely useful task, which does not require in-depth knowledge of
compilers, would be to extend our testsuite to include <a href=
"http://nondot.org/sabre/LLVMNotes/#benchmarks">new programs and benchmarks</a>.
In particular, we are interested in cpu-intensive programs that have few
library dependencies, produce some output that can be used for correctness
testing, and that are redistributable in source form.  Many different programs
are suitable, for example, see <a
href="http://nondot.org/sabre/LLVMNotes/#benchmarks">this list</a> for some
potential candidates.
</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="programs">Compile programs with the LLVM Compiler</a>
</div>

<div class="www_text">

<p>We are always looking for new testcases and benchmarks for use with LLVM.  In
particular, it is useful to try compiling your favorite C source code with LLVM.
If it doesn't compile, try to figure out why or report it to the <a
href="http://lists.llvm.org/pipermail/llvm-bugs/">llvm-bugs</a> list.  If you
get the program to compile, it would be extremely useful to convert the build
system to be compatible with the LLVM Programs testsuite so that we can check it
into SVN and the automated tester can use it to track progress of the
compiler.</p>

<p>When testing a code, try running it with a variety of optimizations, and with
all the back-ends: CBE, llc, and lli.</p>

</div>


<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="benchmark">Benchmark the LLVM compiler</a>
</div>

<div class="www_text">

<p>Find benchmarks either using our <a
href="/nightlytest/">test results</a> or on your own,
where LLVM code generators do not produce optimal code or where another
compiler produces better code.  Try to minimize the test case that demonstrates
the issue.  Then, either <a href="http://bugs.llvm.org/">submit a
bug</a> with your testcase and the code that LLVM produces vs. the code that it
<em>should</em> produce, or even better, see if you can improve the code
generator and submit a patch.  The basic idea is that it's generally quite easy
for us to fix performance problems if we know about them, but we generally don't
have the resources to go finding out why performance is bad.</p>

</div>


<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="statistics">Benchmark Statistics and Warning System</a>
</div>

<div class="www_text">

<p>The <a href='http://llvm.org/perf/db_default/v4/nts/recent_activity'>
LNT perf database</a> has some nice features like detect moving average,
standard deviations, variations, etc. But the report page give too much emphasis
on the individual variation (where noise can be higher than signal), eg.
<a href='http://llvm.org/perf/db_default/v4/nts/graph?plot.0=10.341.3&highlight_run=8943'>
this case</a>.</p>

<p>The first part of the project would be to create an analysis tool that would
track moving averages and report:
<ul>
 <li>If the current result is higher/lower than the previous moving average by
     more than (configurable) S standard deviations</li>
 <li>If the current moving average is more than S standard deviations of the
     Base run</li>
 <li>If the last A moving averages are in constant increase/decrease of more
     than P percent</li>
</ul>

<p>The second part would be to create a web page which would show all related
benchmarks (possibly configurable, like a dashboard) and show the basic statistics
with red/yellow/green colour codes to show status and links to more detailed
analysis of each benchmark.</p>

<p>A possible third part would be to be able to automatically cross reference
different builds, so that if you group them by architecture/compiler/number
of CPUs, this automated tool would understand that the changes are more common
to one particular group.</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="coverage">Improving Coverage Reports</a>
</div>

<div class="www_text">

<p>The <a href='http://llvm.org/reports/coverage/'>
LLVM Coverage Report</a> has a nice interface to show what source lines are
covered by the tests, but it doesn't mentions which tests, which revision and
what architecture is covered.</p>

<p>A project to renovate LCOV would involve:
<ul>
 <li>Making it run on a buildbot, so that we know what commits / architectures
     are covered</li>
 <li>Update the web page to show that information</li>
 <li>Develop a system that would report every buildbot build into the web page
     in a searchable database, like LNT</li>
</ul>

<p>Another idea is to enable the test suite to run all built backends, not only
   the host architecture, so that coverage report can be built in a fast machine
   and have one report per commit without needing to update the buildbots.</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="misc_imp">Miscellaneous Improvements</a>
</div>

<div class="www_text">

<ol>

<li>Completely rewrite bugpoint.  In addition to being a mess, bugpoint suffers
from a number of problems where it will "lose" a bug when reducing.  It should
be rewritten from scratch to solve these and other problems.</li>
<li><a href="http://bugs.llvm.org/show_bug.cgi?id=2116">Add support for
transactions to the PassManager</a> for improved bugpoint.</li>
<li><a href="http://bugs.llvm.org/show_bug.cgi?id=539">Improve bugpoint to
support running tests in parallel on MP machines</a>.</li>
<li>Add MC assembler/disassembler and JIT support to the SPARC port.</li>
<li>Move more optimizations out of the <tt>-instcombine</tt> pass and into
InstructionSimplify.  The optimizations that should be moved are those that
do not create new instructions, for example turning <tt>sub i32 %x, 0</tt>
into <tt>%x</tt>.  Many passes use InstructionSimplify to clean up code as
they go, so making it smarter can result in improvements all over the place.</li>
</ol>

</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="new">Adding new capabilities to LLVM</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">

<p>Sometimes creating new things is more fun than improving existing things.
These projects tend to be more involved and perhaps require more work, but can
also be very rewarding.</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="llvm_ir">Extend the LLVM intermediate representation</a>
</div>

<div class="www_text">

<p>Many proposed <a href="http://nondot.org/sabre/LLVMNotes/">extensions and
improvements to LLVM core</a> are awaiting design and implementation.</p>

<ol>
<li><a href="http://nondot.org/sabre/LLVMNotes/DebugInfoImprovements.txt">Improvements
for Debug Information Generation</a></li>
<li><a href="/PR1269">EH support for non-call exceptions</a></li>
<li>Many ideas for feature requests are stored in LLVM bugzilla.  Search<a
  href="http://bugs.llvm.org/buglist.cgi?short_desc_type=allwordssubstr&amp;short_desc=&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=new-feature&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;emailassigned_to1=1&amp;emailtype1=substring&amp;email1=&amp;emailassigned_to2=1&amp;emailreporter2=1&amp;emailcc2=1&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;changedin=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;namedcmd=All+PRs&amp;newqueryname=&amp;order=Bug+Number&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">for bugs with a "new-feature" keyword</a>.</li>
</ol>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="pointeranalysis">Pointer and Alias Analysis</a>
</div>

<div class="www_text">

<p>We have a <a href="docs/AliasAnalysis.html">strong base for development</a> of
both pointer analysis based optimizations as well as pointer analyses
themselves.  We want to take advantage of this:</p>

<ol>
<li>The globals mod/ref pass does an inexpensive bottom-up context sensitive
  alias analysis.  There are some inexpensive things that we could do to better
  capture the effects of functions that access pointer arguments.  This can be
  really important for C++ methods, which spend lots of time accessing pointers
  off 'this'.</li>

<li>The alias analysis API supports the getModRefBehavior method, which allows
  the implementation to give details analysis of the functions. For example, we
  could implement <a href="/PR1604">full knowledge of
    printf/scanf</a> side effects, which would be useful.  This feature is in
  place but not being used for anything right now.</li>

<li>We need some way to reason about errno.  Consider a loop like this:

<pre>
    for ()
      x += sqrt(loopinvariant);
</pre>

<p>We'd like to transform this into:</p>

<pre>
    t = sqrt(loopinvariant);
    for ()
      x += t;
</pre>

<p>This transformation is safe, because the value of errno isn't
otherwise changed in the loop and the exit value of errno from the
loop is the same.  We currently can't do this, because sqrt clobbers
errno, so it isn't "readonly" or "readnone" and we don't have a good
way to model this.</p>

<p>The important part of this project is figuring out how to describe
errno in the optimizer: each libc #defines errno to something different
it seems.  Maybe the solution is to have a __builtin_errno_addr() or
something and change sys headers to use it.</p>

<li>There are lots of ways to optimize out and <a
href="/PR452">improve handling of
memcpy/memset</a>.</li>

</ol>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="profileguided">Profile-Guided Optimization</a>
</div>

<div class="www_text">

<p>We now have a unified infrastructure for writing profile-guided
transformations, which will work either at offline-compile-time or in the JIT,
but we don't have many transformations.  We would welcome new profile-guided
transformations as well as improvements to the current profiling system.
</p>

<p>Ideas for profile-guided transformations:</p>

<ol>
<li>Superblock formation (with many optimizations)</li>
<li>Loop unrolling/peeling</li>
<li>Profile directed inlining</li>
<li>Code layout</li>
<li>...</li>
</ol>

<p>Improvements to the existing support:</p>

<ol>
<li>The current block and edge profiling code that gets inserted is very simple
and inefficient.  Through the use of control-dependence information, many fewer
counters could be inserted into the code.  Also, if the execution count of a
loop is known to be a compile-time or runtime constant, all of the counters in
the loop could be avoided.</li>

<li>You could implement one of the "static profiling" algorithms which analyze a
piece of code an make educated guesses about the relative execution frequencies
of various parts of the code.</li>

<li>You could add path profiling support, or adapt the existing LLVM path
profiling code to work with the generic profiling interfaces.</li>
</ol>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="compaction">Code Compaction</a>
</div>

<div class="www_text">
<p>LLVM aggressively optimizes for performance, but does not yet optimize for code size.
With a new ARM backend, there is increasing interest in using LLVM for embedded systems
where code size is more of an issue.
</p>

<p>Someone interested in working on implementing code compaction in LLVM might want to read
<a href="http://citeseer.ist.psu.edu/425696.html">this</a> article, describing using
link-time optimizations for code size optimization.
</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="xforms">New Transformations and Analyses</a>
</div>

<div class="www_text">

<ol>
  <li>Implement a Loop Dependence Analysis Infrastructure<br>
    - Design some way to represent and query dep analysis</li>
  <li>Value range propagation pass</li>
  <li>More fun with loops:
    <a href="http://www.cs.ualberta.ca/~amaral/cascon/CDP04/tal.html">
      Predictive Commoning
    </a>
  </li>
  <li>Type inference (aka. devirtualization)</li>
  <li><a href="http://nondot.org/sabre/LLVMNotes/BuiltinUnreachable.txt">Value
      assertions</a> (also <a href="/PR810">PR810</a>).</li>
</ol>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="codegen">Code Generator Improvements</a>
</div>

<div class="www_text">

<ol>
<li>Generalize target-specific backend passes that could be target-independent,
    by adding necessary target hooks and making sure all IR/MI features (such as
    register masks and predicated instructions) are properly handled. Enable these
    for other targets where doing so is demonstrably beneficial.
    For example:
      <ol><li>lib/Target/Hexagon/RDF*</li>
          <li>lib/Target/AArch64/AArch64AddressTypePromotion.cpp</li>
     </ol>
    </li>
<li>Merge the delay slot filling logic that is duplicated into (at least)
    the Sparc and Mips backends into a single target independent pass.
     Likewise, the branch shortening logic in several targets should be merged
     together into one pass.</li>
<li>Implement 'stack slot coloring' to allocate two frame indexes to the same
    stack offset if their live ranges don't overlap.  This can reuse a bunch of
    analysis machinery from LiveIntervals.  Making the stack smaller is good
    for cache use and very important on targets where loads have limited
    displacement like ppc, thumb, mips, sparc, etc.  This should be done as
    a pass before prolog epilog insertion.  This is now done for register
    allocator temporaries, but not for allocas.</li>
<li>Implement 'shrink wrapping', which is the intelligent placement of callee
    saved register save/restores.  Right now PrologEpilogInsertion always saves
    every (modified) callee save reg in the prolog and restores it in the
    epilog, however, some paths through a function (e.g. an early exit) may
    not use all regs.  Sinking the save down the CFG avoids useless work on
    these paths. Work has started on this, please inquire on llvm-dev.</li>
<li>Implement interprocedural register allocation. The CallGraphSCCPass can be
    used to implement a bottom-up analysis that will determine the *actual*
    registers clobbered by a function. Use the pass to fine tune register usage
    in callers based on *actual* registers used by the callee.</li>
<li>Add support for 16-bit x86 assembly and real mode to the assembler and
    disassembler, for use by BIOS code. This includes both 16-bit instruction
    encodings as well as privileged instructions (lgdt, lldt, ltr, lmsw, clts,
    invd, invlpg, wbinvd, hlt, rdmsr, wrmsr, rdpmc, rdtsc) and the control and
    debug registers.
</ol>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="misc_new">Miscellaneous Additions</a>
</div>

<div class="www_text">

<ol>
<li>Port the <a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/">Bigloo</A>
Scheme compiler, from Manuel Serrano at INRIA Sophia-Antipolis, to
output LLVM bytecode. It seems that it can already output .NET
bytecode, JVM bytecode, and C, so LLVM would ostensibly be another good
candidate.</li>
<li>Write a new frontend for some other language (Java? OCaml? Forth?)</li>
<li>Random test vector generator: Use a C grammar to generate random C code,
e.g., <a href="http://code.google.com/p/quest-tester/">quest</a>;
run it through llvm-gcc, then run a random set of passes on it using opt.
Try to crash <tt><a href="/docs/CommandGuide/html/opt.html">opt</a></tt>. When
<tt>opt</tt> crashes, use <tt><a
href="/docs/CommandGuide/html/bugpoint.html">bugpoint</a></tt> to reduce the
test case and post it to a website or mailing list.  Repeat ad infinitum.</li>
<li>Add sandbox features to the Interpreter: catch invalid memory accesses,
  potentially unsafe operations (access via arbitrary memory pointer) etc.
</li>
<li>Port <a href="http://valgrind.org">Valgrind</a> to use LLVM code generation
  and optimization passes instead of its own.</li>
<li>Write LLVM IR level debugger (extend Interpreter?)</li>
<li>Write an LLVM Superoptimizer.  It would be interesting to take ideas from
    this superoptimizer for x86:
<a href="http://theory.stanford.edu/~aiken/publications/papers/asplos06.pdf">paper #1</a> and <a href="http://theory.stanford.edu/~sbansal/superoptimizer.html">paper #2</a> and adapt them to run on LLVM code.<p>

It would seem that operating on LLVM code would save a lot of time
because its semantics are much simpler than x86.  The cost of operating
on LLVM is that target-specific tricks would be missed.<p>

The outcome would be a new LLVM pass that subsumes at least the
instruction combiner, and probably a few other passes as well.  Benefits
would include not missing cases missed by the current combiner and also
more easily adapting to changes in the LLVM IR.<p>

All previous superoptimizers have worked on linear sequences of code.
It would seem much better to operate on small subgraphs of the program
dependency graph.</li>
</ol>

</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="using">Projects using LLVM</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">

  <p>
  In addition to projects that enhance the existing LLVM infrastructure, there
  are projects that improve software that uses, but is not included with, the
  LLVM compiler infrastructure.  These projects include open-source software
  projects and research projects that use LLVM.  Like projects that enhance the
  core LLVM infrastructure, these projects are often challenging and rewarding.
  </p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="encodeanalysis">Encode Analysis Results in MachineInstr IR</a>
</div>

<div class="www_text">
  <p>
  At least one project (and probably more) needs to use analysis information
  (such as call graph analysis) from within a MachineFunctionPass, however,
  most analysis passes operate at the LLVM IR level.  In some cases, a value
  (e.g., a function pointer) cannot be mapped from the MachineInstr level back
  to the LLVM IR level reliably, making the use of existing LLVM analysis
  passes from within a MachineFunctionPass impossible (or at least brittle).
  </p>

  <p>
  This project is to encode analysis information from the LLVM IR level into
  the MachineInstr IR when it is generated so that it is available to a
  MachineFunctionPass.  The exemplar is call graph analysis (useful for
  control-flow integrity instrumentation, analysis of code reuse defenses, and
  gadget compilers); however, other LLVM analyses may be useful.
  </p>
</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="codelayoutjit">Code Layout in the LLVM JIT</a>
</div>

<div class="www_text">
  <p>
  Implement an on-demand function relocator in the LLVM JIT. This can help
  improve code locality using runtime profiling information. The idea is to use
  a relocation table for every function.  The relocation entries need to be
  updated upon every function relocation (take a look at
  <a href="https://people.cs.umass.edu/~emery/pubs/stabilizer-asplos13.pdf">
  this article</a>).
  A (per-function) basic block reordering would be a useful extension.
  </p>
</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="fieldlayout">Improved Structure Splitting and Field Reordering</a>
</div>

<div class="www_text">
  <p>
  The goal of this project is to implement better data layout optimizations
  using the model of reference affinity.  This
  <a href="http://www.cs.rochester.edu/~cding/Documents/Publications/pldi04.pdf">
  paper</a>
  provides some background information.
  </p>
</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="slimmer">Finish the Slimmer Project</a>
</div>

<div class="www_text">
  <p>
  Slimmer is a prototype tool, built using LLVM, that uses dynamic analysis to
  find potential performance bugs in programs.  Development on Slimmer started
  during Google Summer of Code in 2015 and resulted in an initial prototype,
  but evaluation of the prototype and improvements to make it portable and
  robust are still needed.  This project would have a student pick up and
  finish the Slimmer work.  The source code of Slimmer and
  its current documentation can be found at its
  <a href="https://github.com/james0zan/Slimmer">Github</a> web page.
  </p>
</div>

<!-- *********************************************************************** -->

<hr>

<!--#include virtual="footer.incl" -->
